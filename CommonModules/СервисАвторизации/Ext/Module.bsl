//Модуль отвечает за авторизацию, аутентификацию и идентификацию пользователей

// Авторизация пользователя на сервере
&НаСервере
Функция АвторизоватьПользователяНаСервере(Логин, Пароль, АдресЦентральнойБазы, КодУзла, НаименованиеУстройства) Экспорт
    Результат = Новый Структура("Успех, КодУзла, Ошибка", Ложь, "", "");

    // Подключение к веб-сервису
    WSПрокси = СетевоеСоединение.ПодключитьсяКВебСервису(АдресЦентральнойБазы, Результат);
    Если WSПрокси = Неопределено Тогда
        Возврат Результат;
    КонецЕсли;

    // Проверка авторизации
    Попытка
        РезультатАвторизации = WSПрокси.АвторизоватьПользователя(Логин, Пароль);        
        Массив = СтрРазделить(РезультатАвторизации, " ");    
        ОбновитьПользователя(Массив[3], Массив[2], Массив[0], Массив[1], Массив[4]);
    Исключение
        Результат.Ошибка = "Ошибка авторизации2: " + ОписаниеОшибки();
        Возврат Результат;
    КонецПопытки;
    
    Если ПустаяСтрока(РезультатАвторизации) Тогда
        Результат.Ошибка = "Неверный логин или пароль!";
        Возврат Результат;
    КонецЕсли;
    
    Результат.Успех = Истина;

    Возврат Результат;
КонецФункции

// Регистрация на сервере
&НаСервере
Функция РегистрацияНаСервере(Пароль, Логин, РольПользователя) Экспорт
	    // Подключение к веб-сервису
    Попытка
        WSОпределения = Новый WSОпределения(ПолучениеДанныхДляСоединения.ПолучитьURLЦентральнойБазы());
		WSПрокси = Новый WSПрокси(WSОпределения, ПолучитьПроостранствоИмен(), "AuthService", "AuthServiceSoap");
		
    Исключение
        Возврат "";
	КонецПопытки;
	
	// Вызов метода регистрации в веб-сервисе
    Попытка
    	РольСтрокой = "";
    	Если РольПользователя = Перечисления.Роль.Пассажир Тогда
        	РольСтрокой = "Пассажир";
    	ИначеЕсли РольПользователя = Перечисления.Роль.Водитель Тогда
        	РольСтрокой = "Водитель";
		ИначеЕсли РольПользователя = Перечисления.Роль.Администратор Тогда
        	РольСтрокой = "Администратор";
		КонецЕсли;
				
        Ответ = WSПрокси.РегистрацияПользователя(Логин, Пароль, РольСтрокой);
		Если НЕ ПустаяСтрока(Ответ) Тогда
			Если НЕ Ответ = "0" Тогда 
				Массив = СтрРазделить(Ответ, " ");
				ОбновитьПользователя(Массив[0], Массив[1], Массив[4], Массив[3], Массив[2]);
				
				Возврат "Пользователь успешно зарегистрирован.";				
			Иначе
				Возврат "Пользователь с таким логином уже существует!";
			КонецЕсли;
			
        Иначе
            Возврат "";
        КонецЕсли;
	Исключение
        Возврат "";
    КонецПопытки;
	
КонецФункции

//Возвращает пространтсво имен
&НаСервере
Функция ПолучитьПроостранствоИмен() Экспорт 
	Попытка
		//Обращение к константе
        Возврат Константы.ПространствоИменВебСервиса.Получить();
	Исключение
        Возврат "";
    КонецПопытки;
КонецФункции

// Обновление учетной записи если данные совпадают с сервером на локальном устройстве
&НаСервере
Функция ОбновитьПользователя(Наименование, Роль, Логин, Пароль, Код) Экспорт
    Результат = Новый Структура("Успех, Сообщение", Ложь, "");
    
    // Поиск пользователя по коду
    ПользовательСсылка = Справочники.Пользователи.НайтиПоКоду(Код);
    
    Попытка
        НачатьТранзакцию();
        
        Если ЗначениеЗаполнено(ПользовательСсылка) Тогда
            // Обновляем существующую запись
            ПользовательОбъект = ПользовательСсылка.ПолучитьОбъект();
        Иначе
            // Создаём новую запись
            ПользовательОбъект = Справочники.Пользователи.СоздатьЭлемент();
            ПользовательОбъект.Код = Код;
        КонецЕсли;
        
        // Заполняем поля
        ПользовательОбъект.Наименование = Наименование;
		    // Преобразование строки роли в перечисление
    	РольПеречисление = Неопределено;
    	Если Роль = "Пассажир" Тогда
        	РольПеречисление = Перечисления.Роль.Пассажир;
    	ИначеЕсли Роль = "Водитель" Тогда
        	РольПеречисление = Перечисления.Роль.Водитель;
    	Иначе
        	Результат.Сообщение = "Недопустимое значение роли: " + Роль;
        	Сообщить(Результат.Сообщение, СтатусСообщения.Важное);
        	Возврат Результат;
    	КонецЕсли;
        ПользовательОбъект.Роль = РольПеречисление;
        ПользовательОбъект.Логин = Логин;
        ПользовательОбъект.Пароль = Пароль;
        
        // Записываем объект
        ПользовательОбъект.Записать();
        
        ЗафиксироватьТранзакцию();
        
        Результат.Успех = Истина;
        Результат.Сообщение = "Пользователь успешно " + ?(ЗначениеЗаполнено(ПользовательСсылка), "обновлён", "создан") + "!";
        
    Исключение
        ОтменитьТранзакцию();
        Результат.Сообщение = "Ошибка при записи пользователя: " + ОписаниеОшибки();
    КонецПопытки;
    
    Возврат Результат;
КонецФункции

// Создание идентифкатора пользователя на сервере
&НаСервере
Функция ГенерацияУникальногоНаименования() Экспорт
	БазовоеНаименование = "Пользователь";
    Попытка
        // Проверка входных данных
        Если ПустаяСтрока(БазовоеНаименование) Тогда
            БазовоеНаименование = "Пользователь";
        КонецЕсли;
        
        // Начальное наименование
        УникальноеНаименование = БазовоеНаименование;
        Счетчик = 0;
        
        // Проверка уникальности
        Пока Истина Цикл
            Запрос = Новый Запрос;
            Запрос.Текст = 
                "ВЫБРАТЬ ПЕРВЫЕ 1
                |    Пользователи.Ссылка
                |ИЗ
                |    Справочник.Пользователи КАК Пользователи
                |ГДЕ
                |    Пользователи.Наименование = &Наименование";
            Запрос.УстановитьПараметр("Наименование", УникальноеНаименование);
            
            РезультатЗапроса = Запрос.Выполнить();
            
            // Если наименование уникально, возвращаем его
            Если РезультатЗапроса.Пустой() Тогда
                Возврат УникальноеНаименование;
            КонецЕсли;
            
            // Если наименование занято, добавляем суффикс
            Счетчик = Счетчик + 1;
            УникальноеНаименование = БазовоеНаименование + "_" + Формат(Счетчик, "ЧГ=0");
            
            // Защита от бесконечного цикла
            Если Счетчик > 10000 Тогда
                Возврат "";
            КонецЕсли;
        КонецЦикла;
        
    Исключение
        Возврат "";
    КонецПопытки;
КонецФункции

// Создание кода для узла обмена
&НаСервере
Функция ГенерацияУникальногоКода() Экспорт
    Попытка
        // Запрос для получения максимального кода
        Запрос = Новый Запрос;
        Запрос.Текст = 
            "ВЫБРАТЬ ПЕРВЫЕ 1
            |    Пользователи.Код КАК Код
            |ИЗ
            |    Справочник.Пользователи КАК Пользователи
            |ГДЕ
            |    Пользователи.Код ПОДОБНО ""[0-9][0-9][0-9]""
            |УПОРЯДОЧИТЬ ПО
            |    Код УБЫВ";
        
        РезультатЗапроса = Запрос.Выполнить();
        
        НовыйКод = 1; // Начальный код, если справочник пуст
        
        Если Не РезультатЗапроса.Пустой() Тогда
            Выборка = РезультатЗапроса.Выбрать();
            Выборка.Следующий();
            ТекущийКод = Выборка.Код;
            
        КонецЕсли;
        
        // Формируем новый код с ведущими нулями
        УникальныйКод = Формат(НовыйКод, "ЧЦ=3; ЧВН=; ЧГ=0");
        
        // Проверка на превышение максимального значения
        Если НовыйКод > 999 Тогда
            Возврат "";
        КонецЕсли;
        
        // Дополнительная проверка уникальности
        Запрос = Новый Запрос;
        Запрос.Текст = 
            "ВЫБРАТЬ
            |    Пользователи.Ссылка
            |ИЗ
            |    Справочник.Пользователи КАК Пользователи
            |ГДЕ
            |    Пользователи.Код = &Код";
        Запрос.УстановитьПараметр("Код", УникальныйКод);
        
        Если Запрос.Выполнить().Пустой() Тогда
            Возврат УникальныйКод;
        КонецЕсли;
        
        Возврат "";
        
    Исключение
        Возврат "";
    КонецПопытки;
КонецФункции

// Проверка наличия данных для подключения к серверу
&НаСервере
Функция ПроверитьКонстанты() Экспорт
	ПространствоИмен = Константы.ПространствоИменВебСервиса.Получить();
	АдресБазы = ПолучениеДанныхДляСоединения.ПолучитьURLЦентральнойБазы();
	
	Если НЕ ПустаяСтрока(ПространствоИмен) И НЕ ПустаяСтрока(АдресБазы) Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

// Проверка на мобильное устройство
&НаСервере
Процедура ПроверитьУстройства(Статус) Экспорт
	ПараметрыСеанса.ЭтоМобильныйКлиент = Статус;
КонецПроцедуры

// Проверка узла обмена
&НаСервере
Процедура ПроверкаУзла() Экспорт
	
	КодЦентральный = Константы.КодУзлаЦентральнойБазы.Получить();
	НазваниеЦентральнойБазы = Константы.НазваниеЦентральногоУзла.Получить();
	КодКлиента = Константы.КодНовогоУзлаПланаОбмена.Получить();
	НазваниеУстройства = Константы.НазваниеУзлаУстройства.Получить();
	
	Если НЕ (ПустаяСтрока(КодЦентральный) И ПустаяСтрока(НазваниеЦентральнойБазы) И ПустаяСтрока(КодКлиента) И ПустаяСтрока(НазваниеУстройства)) Тогда 
		// Вывод сообщений с подписями
		СинхронизацияМобильногоУстройства.СинхронизироватьДанныеНажатие();
	Иначе 
			
	URL = ПолучениеДанныхДляСоединения.ПолучитьURLЦентральнойБазы();
	ПространствоИмен = ПолучениеДанныхДляСоединения.ПолучитьПроостранствоИмен();
	
	// Подключение к веб-сервису
    Попытка
        WSОпределения = Новый WSОпределения(URL);
		WSПрокси = Новый WSПрокси(WSОпределения, ПространствоИмен, "AuthService", "AuthServiceSoap");
		
    Исключение
        Сообщить("Ошибка подключения!");
	КонецПопытки;
	
	    //Проверка авторизации
	Попытка
        РезультатУзла = WSПрокси.ДобавитьУзел();
		РазобратьСтрокуУзловОбмена(РезультатУзла);
		СинхронизацияМобильногоУстройства.СинхронизироватьДанныеНажатие();
    Исключение
		Сообщить("Ошибка соединения!");
	КонецПопытки;

	
	КонецЕсли
	
КонецПроцедуры

// Работа с узлом центральной базы 
&НаСервере
Процедура РазобратьСтрокуУзловОбмена(СтрокаУзлов)

    // Разделение строки по пробелам
    ЧастиСтроки = СтрРазделить(СтрокаУзлов, " ", Ложь);

    // Проверка, что строка содержит ровно 4 части
	Если ЧастиСтроки.Количество() = 4 Тогда
		
		// Запись значений констант
    	Попытка
        	Константы.КодУзлаЦентральнойБазы.Установить(ЧастиСтроки[0]);
        	Константы.КодНовогоУзлаПланаОбмена.Установить(ЧастиСтроки[2]);
	    	Константы.НазваниеЦентральногоУзла.Установить(ЧастиСтроки[1]);
        	Константы.НазваниеУзлаУстройства.Установить(ЧастиСтроки[3]);
    	Исключение
        	Сообщить("Ошибка записи констант: " + ОписаниеОшибки());
        	ВызватьИсключение "Не удалось записать константы: " + ОписаниеОшибки();
		КонецПопытки;
	
		// Обновление плана обмена "Мобильные"
    	Попытка
        	// Обновление главного узла текущей базы
        	ГлавныйУзел = ПланыОбмена.Мобильные.ЭтотУзел();
        	Если ГлавныйУзел <> ПланыОбмена.Мобильные.ПустаяСсылка() Тогда
            	ГлавныйУзелОбъект = ГлавныйУзел.ПолучитьОбъект();
            	ГлавныйУзелОбъект.Код = ЧастиСтроки[2];
            	ГлавныйУзелОбъект.Наименование = ЧастиСтроки[3];
            	ГлавныйУзелОбъект.Записать();
        	КонецЕсли;
        
        	// Проверка и создание узла центральной базы
        	УзелЦентральнойБазы = ПланыОбмена.Мобильные.НайтиПоКоду(ЧастиСтроки[0]);
        	Если УзелЦентральнойБазы.Пустая() Тогда
            	НовыйУзел = ПланыОбмена.Мобильные.СоздатьУзел();
            	НовыйУзел.Код = ЧастиСтроки[0];
            	НовыйУзел.Наименование = ЧастиСтроки[1];
            	НовыйУзел.Записать();
        	КонецЕсли;
        
    	Исключение
        	Сообщить("Ошибка обновления плана обмена: " + ОписаниеОшибки());
        	ВызватьИсключение "Не удалось обновить план обмена: " + ОписаниеОшибки();
    	КонецПопытки;
		
    	Иначе
        	ВызватьИсключение "Некорректный формат строки. Ожидается 4 части, разделенные пробелами.";
    	КонецЕсли;
КонецПроцедуры

// Функция хэширует строку (пароль) с солью и возвращает хэш и соль в одной строке
Функция ХэшироватьПароль(Пароль) Экспорт
    Попытка
        // Проверка входных данных
        Если ПустаяСтрока(Пароль) Тогда
            Возврат "";
        КонецЕсли;
        
        // Генерация соли
        Соль = ПолучитьСлучайнуюСоль();
        Итерации = 100000; // Количество итераций для замедления
        
        // Хэширование пароля с солью
        Хеширование = Новый ХешированиеДанных(ХешФункция.SHA256);
        ТекущийХэш = Пароль + Соль;
        Для Сч = 1 По Итерации Цикл
            Хеширование.Добавить(ТекущийХэш);
            ТекущийХэш = ПолучитьHexСтрокуИзДвоичныхДанных(Хеширование.ХешСумма);
            Хеширование = Новый ХешированиеДанных(ХешФункция.SHA256);
        КонецЦикла;
        Хэш = ТекущийХэш;
        
        // Возвращаем хэш и соль в формате "хэш:соль"
        Возврат Хэш + ":" + Соль;
    Исключение
        Сообщить("Ошибка при хэшировании пароля: " + ОписаниеОшибки(), СтатусСообщения.Важное);
        Возврат "";
    КонецПопытки;
КонецФункции

// Проверка пароля
Функция ПроверитьПароль(ХэшИСоль, ПроверяемыйПароль) Экспорт
    Попытка
        // Проверка входных данных
        Если ПустаяСтрока(ХэшИСоль) Тогда
            Возврат Ложь;
        КонецЕсли;
        Если ПустаяСтрока(ПроверяемыйПароль) Тогда
            Возврат Ложь;
        КонецЕсли;
        
        // Разделяем строку на хэш и соль
        Части = СтрРазделить(ХэшИСоль, ":", Истина);
        Если Части.Количество() <> 2 Тогда
            Возврат Ложь;
        КонецЕсли;
        Хэш = Части[0];
        Соль = Части[1];
        
        // Хэширование проверяемого пароля с той же солью и итерациями
        Итерации = 100000; // Должно совпадать с количеством итераций в ХэшироватьПароль
        Хеширование = Новый ХешированиеДанных(ХешФункция.SHA256);
        ТекущийХэш = ПроверяемыйПароль + Соль;
        Для Сч = 1 По Итерации Цикл
            Хеширование.Добавить(ТекущийХэш);
            ТекущийХэш = ПолучитьHexСтрокуИзДвоичныхДанных(Хеширование.ХешСумма);
            Хеширование = Новый ХешированиеДанных(ХешФункция.SHA256);
        КонецЦикла;
        ХэшПроверяемого = ТекущийХэш;
        
        // Сравнение хэшей
        Если Хэш = ХэшПроверяемого Тогда
            Возврат Истина;
        Иначе
            Возврат Ложь;
        КонецЕсли;
        
    Исключение
        Сообщить("Ошибка при проверке пароля: " + ОписаниеОшибки(), СтатусСообщения.Важное);
        Возврат Ложь;
    КонецПопытки;
КонецФункции

// Генератор соли
Функция ПолучитьСлучайнуюСоль()
    Генератор = Новый ГенераторСлучайныхЧисел;
    Соль = "";
    Для Сч = 1 По 16 Цикл // 16 байт соли
        Соль = Соль + Символ(Генератор.СлучайноеЧисло(33, 126));
    КонецЦикла;
    Возврат Соль;
КонецФункции

// Запись учетных данных администратора
&НаСервере
Процедура РегистрацияАдминистратора(Пароль, Логин)Экспорт 
	
	ПарольАдминистратораХэш = ХэшироватьПароль(Пароль);
	ЛогинАдминистратораХэш = ХэшироватьПароль(Логин);
	
	ЗаполнитьАдминистратора(ЛогинАдминистратораХэш, ПарольАдминистратораХэш);
		
КонецПроцедуры

// Процедура заполняет справочник "Администраторы" с переданными логином и паролем
Процедура ЗаполнитьАдминистратора(Логин, Пароль) Экспорт
	
	// Проверяем входные параметры
	Если ПустаяСтрока(Логин) Или ПустаяСтрока(Пароль) Тогда
		Сообщить("Ошибка: Логин и Пароль должны быть заполнены.");
		Возврат;
	КонецЕсли;
	
	// Генерируем уникальный идентификатор
	Идентификатор = СгенерироватьСтроковыйИдентификатор();
	
	// Проверяем, существует ли элемент с таким идентификатором
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Администраторы.Ссылка
		|ИЗ
		|	Справочник.Администраторы КАК Администраторы
		|ГДЕ
		|	Администраторы.Наименование = &Идентификатор";
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	
	// Пока идентификатор не уникален, генерируем новый
	Пока НЕ Запрос.Выполнить().Пустой() Цикл
		Идентификатор = СгенерироватьСтроковыйИдентификатор();
		Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	КонецЦикла;
	
	// Создаём новый элемент справочника
	НовыйЭлемент = Справочники.Администраторы.СоздатьЭлемент();
	НовыйЭлемент.Наименование = Идентификатор;
	НовыйЭлемент.Логин = Логин;
	НовыйЭлемент.Пароль = Пароль;
	
	// Записываем элемент
	Попытка
		НовыйЭлемент.Записать();
		Сообщить("Создан администратор: " + Логин + " с идентификатором: " + Идентификатор);
	Исключение
		Сообщить("Ошибка при создании администратора: " + ОписаниеОшибки());
	КонецПопытки;

КонецПроцедуры

// Функция генерирует случайный строковый идентификатор
Функция СгенерироватьСтроковыйИдентификатор() Экспорт
	
	// Локальная переменная для символов
	НаборСимволов = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	ДлинаИдентификатора = 32;
	
	Генератор = Новый ГенераторСлучайныхЧисел;
	Результат = "";
	
	Для Сч = 1 По ДлинаИдентификатора Цикл
		Индекс = Генератор.СлучайноеЧисло(1, СтрДлина(НаборСимволов));
		Результат = Результат + Сред(НаборСимволов, Индекс, 1);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

//Функция аутентификации и идентификации на сервере
Функция ПроверитьУчетныеДанныеАдминистратора(ЛогинВведенный, ПарольВведенный) Экспорт
		
	// Запрос к справочнику Администраторы
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Администраторы.Логин КАК Логин,
		|	Администраторы.Пароль КАК Пароль
		|ИЗ
		|	Справочник.Администраторы КАК Администраторы";
	
	Результат = Запрос.Выполнить();
	
	// Если справочник пуст
	Если Результат.Пустой() Тогда
		Возврат "Неверный логин";
	КонецЕсли;
	
	// Проверяем каждую запись
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		// Проверяем логин через СервисАвторизации.ПроверитьПароль
		ЛогинВерный = СервисАвторизации.ПроверитьПароль(Выборка.Логин, ЛогинВведенный);
		
		// Проверяем пароль
		ПарольВерный = СервисАвторизации.ПроверитьПароль(Выборка.Пароль, ПарольВведенный);
		
		// Если и логин, и пароль верны
		Если ЛогинВерный И ПарольВерный Тогда
			Возврат "Вход успешен";
		КонецЕсли;
		
	КонецЦикла;
	
	// Если цикл завершён, но совпадений нет
	// Проверяем, был ли хотя бы один верный логин
	Выборка.Сбросить();
	ЛогинНайден = Ложь;
	Пока Выборка.Следующий() Цикл
		Если СервисАвторизации.ПроверитьПароль(Выборка.Логин, ЛогинВведенный) Тогда
			ЛогинНайден = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ЛогинНайден Тогда
		Возврат "Неверный пароль";
	Иначе
		Возврат "Неверный логин";
	КонецЕсли;
	
КонецФункции

// Устанавливает параметр сеанса для администратора, если "Ложь" то доступ на немобильном клиенте к справочникам и
// документам будет закрыт, если истина, то администратор успешно прошел идентификацию и аутентификацию, поэтому
// он может начать работу
&НаСервере
Процедура ПараметрАдминистратора(ПеременнаяАдминистратора) Экспорт 
	
	ПараметрыСеанса.Администрирование = ПеременнаяАдминистратора;	
	
КонецПроцедуры

// Вовращает параметр сеанса для администратора
&НаСервере
Функция ПолучениеПараметраСеансаАдминистратора() Экспорт 
	
	Возврат ПараметрыСеанса.Администрирование;
	
КонецФункции
